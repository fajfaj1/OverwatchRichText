It could be possible to resolve conflicts of selection with existing spans by analysis of intersections and appropriate span edits.
The implementation turned out to be surprisingly difficult, therefore I abandon the idea for the time being.
Here are code snippets which may be useful when trying to implement it:


function findIntersectionType(spanRange: Range, selectionRange: Range) {
    let intersectType:
        | 'span_start_in_selection'
        | 'span_end_in_selection'
        | 'whole_span_in_selection'
        | 'no_intersection' = 'no_intersection';
    const isSpanStartInside =
        spanRange.compareBoundaryPoints(
            Range.START_TO_START,
            selectionRange
        ) === 1 &&
        spanRange.compareBoundaryPoints(Range.END_TO_START, selectionRange) ===
            -1;

    const isSpanEndInside =
        spanRange.compareBoundaryPoints(Range.START_TO_END, selectionRange) ===
            1 &&
        spanRange.compareBoundaryPoints(Range.END_TO_END, selectionRange) ===
            -1;
    if (isSpanStartInside) {
        intersectType = 'span_start_in_selection';
    }
    if (isSpanEndInside) {
        intersectType = 'span_end_in_selection';
        if (isSpanStartInside) {
            intersectType = 'whole_span_in_selection';
        }
    }
    return intersectType;
}


inputNode.querySelectorAll('span').forEach((span) => {
            // Compare selection and span boundries to determine how they intersect
            const spanRange = new Range();
            spanRange.selectNode(inputNode);
            spanRange.setStartBefore(span);
            spanRange.setEndAfter(span);
            const intersectionType = findIntersectionType(
                spanRange,
                selectionRange
            );

            const contentRange = new Range();
            contentRange.selectNodeContents(span);
            const contents = contentRange.cloneContents();
            const newSpan = span.cloneNode();
            let overlap = 0;
            switch (intersectionType) {
                case 'whole_span_in_selection':
                    spanRange.deleteContents();
                    spanRange.insertNode(contents);
                    break;
                case 'span_start_in_selection':
                    overlap = selectionRange.endOffset;
                    newSpan.textContent = contents.textContent.slice(overlap);
                    spanRange.deleteContents();
                    contents.textContent = contents.textContent.slice(
                        0,
                        overlap
                    );
                    spanRange.insertNode(newSpan);
                    spanRange.insertNode(contents);

                    break;
            }
        });